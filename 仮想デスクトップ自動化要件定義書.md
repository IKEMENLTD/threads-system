# 📋 Threads仮想デスクトップ自動化システム要件定義書

**プロジェクト名**: Threads Browser Automation System (TBAS)  
**バージョン**: 1.0.0  
**作成日**: 2025年1月15日  
**ステータス**: Threads API代替ソリューション

## 1. 背景と目的

### 1.1 背景
- Threads公式APIの接続が困難
- Meta Business認証の複雑性
- APIレート制限の厳しさ

### 1.2 目的
- ブラウザ自動化による確実な投稿
- 画像認識による状態確認
- 人間の操作を模倣した安全な自動化

## 2. システム概要

### 2.1 アーキテクチャ
```
[HTMLボタン] → [WebSocket] → [Python自動化サーバー]
                                    ↓
                            [仮想ブラウザ/Selenium]
                                    ↓
                            [Threads Webサイト]
                                    ↓
                            [OCR/画像認識]
                                    ↓
                            [結果をDBに保存]
```

### 2.2 主要技術スタック
| コンポーネント | 技術 | 用途 |
|--------------|------|------|
| ブラウザ自動化 | Selenium/Playwright | Web操作自動化 |
| 画像認識 | Tesseract OCR | テキスト読み取り |
| 画像処理 | OpenCV | 要素検出 |
| スクリーンショット | Pillow | 画面キャプチャ |
| 仮想ディスプレイ | Xvfb (Linux) | ヘッドレス実行 |
| WebSocket | socket.io | リアルタイム通信 |
| タスクキュー | Celery | 非同期処理 |

## 3. 機能要件

### 3.1 基本機能

#### 3.1.1 ログイン機能
```python
機能ID: TBAS-001
機能名: 自動ログイン
説明: Threadsにブラウザ経由でログイン
入力:
  - username: str (Instagram/Threadsユーザー名)
  - password: str (パスワード)
  - two_factor_code: str (2段階認証コード、オプション)
出力:
  - success: bool
  - session_cookies: dict
  - error_message: str
```

#### 3.1.2 投稿作成機能
```python
機能ID: TBAS-002
機能名: 投稿作成・公開
説明: テキスト/画像を投稿
入力:
  - content: str (投稿内容)
  - images: list[str] (画像パス、最大10枚)
  - hashtags: list[str] (ハッシュタグ)
出力:
  - post_url: str (投稿URL)
  - post_id: str (投稿ID、OCRで取得)
  - screenshot: str (投稿完了画面のスクリーンショット)
```

#### 3.1.3 投稿状態確認
```python
機能ID: TBAS-003
機能名: OCR投稿確認
説明: 画像認識で投稿の成功を確認
入力:
  - screenshot: Image
処理:
  1. 「投稿しました」テキストをOCRで検出
  2. いいね数、コメント数を読み取り
  3. エラーメッセージの検出
出力:
  - status: str (success/failed/pending)
  - metrics: dict (likes, comments, shares)
```

### 3.2 高度な機能

#### 3.2.1 人間的な操作模倣
```python
機能ID: TBAS-004
機能名: Human-like Behavior
説明: 人間の操作を模倣してBot検出を回避
実装:
  - ランダムな待機時間 (1-3秒)
  - マウスの自然な動き
  - タイピング速度の変動
  - スクロール動作
  - ランダムなクリック位置のずれ
```

#### 3.2.2 キャプチャ対応
```python
機能ID: TBAS-005
機能名: CAPTCHA処理
説明: キャプチャが表示された場合の処理
実装:
  - キャプチャ画像の検出
  - 管理者への通知
  - 手動解決待機
  - 2captcha/Anti-Captcha API連携（オプション）
```

## 4. 実装仕様

### 4.1 Pythonモジュール構成
```
python/
├── browser_automation/
│   ├── __init__.py
│   ├── driver_manager.py      # ブラウザドライバー管理
│   ├── threads_bot.py         # Threads操作クラス
│   ├── ocr_processor.py       # OCR処理
│   └── human_simulator.py     # 人間的動作
├── server/
│   ├── websocket_server.py    # WebSocket サーバー
│   ├── task_queue.py          # Celeryタスク
│   └── api_endpoints.py       # REST API
├── utils/
│   ├── screenshot.py          # スクリーンショット
│   ├── image_recognition.py   # 画像認識
│   └── security.py            # セキュリティ
└── config.py                  # 設定
```

### 4.2 HTMLテストインターフェース
```html
<!-- test_automation.html -->
<!DOCTYPE html>
<html lang="ja">
<head>
    <title>Threads自動化テストパネル</title>
    <meta charset="UTF-8">
    <style>
        .control-panel {
            max-width: 800px;
            margin: 50px auto;
            padding: 30px;
            border: 2px solid #333;
            border-radius: 10px;
        }
        .status-display {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 5px;
            min-height: 200px;
            font-family: monospace;
        }
        .btn-action {
            padding: 15px 30px;
            font-size: 18px;
            margin: 10px;
            cursor: pointer;
            border-radius: 5px;
            border: none;
        }
        .btn-start { background: #4CAF50; color: white; }
        .btn-stop { background: #f44336; color: white; }
        .btn-test { background: #2196F3; color: white; }
        .screenshot-preview {
            max-width: 100%;
            margin-top: 20px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <h1>🤖 Threads自動化テストパネル</h1>
        
        <div class="section">
            <h2>1. ログインテスト</h2>
            <input type="text" id="username" placeholder="ユーザー名">
            <input type="password" id="password" placeholder="パスワード">
            <button class="btn-action btn-test" onclick="testLogin()">ログインテスト</button>
        </div>
        
        <div class="section">
            <h2>2. 投稿テスト</h2>
            <textarea id="post-content" rows="4" style="width:100%;" 
                placeholder="投稿内容を入力..."></textarea>
            <input type="file" id="post-image" accept="image/*" multiple>
            <button class="btn-action btn-test" onclick="testPost()">投稿テスト</button>
        </div>
        
        <div class="section">
            <h2>3. 自動化制御</h2>
            <button class="btn-action btn-start" onclick="startAutomation()">
                ▶️ 自動化開始
            </button>
            <button class="btn-action btn-stop" onclick="stopAutomation()">
                ⏹️ 停止
            </button>
            <button class="btn-action btn-test" onclick="captureScreen()">
                📸 画面キャプチャ
            </button>
        </div>
        
        <div class="section">
            <h2>4. ステータス</h2>
            <div class="status-display" id="status-display">
                待機中...
            </div>
        </div>
        
        <div class="section">
            <h2>5. スクリーンショット</h2>
            <img id="screenshot-preview" class="screenshot-preview" style="display:none;">
        </div>
    </div>
    
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io('http://localhost:8888');
        const statusDisplay = document.getElementById('status-display');
        
        // WebSocket接続
        socket.on('connect', () => {
            addStatus('✅ サーバー接続成功');
        });
        
        socket.on('status', (data) => {
            addStatus(data.message);
        });
        
        socket.on('screenshot', (data) => {
            document.getElementById('screenshot-preview').src = data.image;
            document.getElementById('screenshot-preview').style.display = 'block';
        });
        
        socket.on('error', (data) => {
            addStatus('❌ エラー: ' + data.message);
        });
        
        function addStatus(message) {
            const timestamp = new Date().toLocaleTimeString();
            statusDisplay.innerHTML += `[${timestamp}] ${message}\n`;
            statusDisplay.scrollTop = statusDisplay.scrollHeight;
        }
        
        function testLogin() {
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            
            socket.emit('test_login', {
                username: username,
                password: password
            });
            addStatus('🔐 ログインテスト開始...');
        }
        
        function testPost() {
            const content = document.getElementById('post-content').value;
            const files = document.getElementById('post-image').files;
            
            // 画像をBase64に変換
            const images = [];
            for (let file of files) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    images.push(e.target.result);
                };
                reader.readAsDataURL(file);
            }
            
            setTimeout(() => {
                socket.emit('test_post', {
                    content: content,
                    images: images
                });
                addStatus('📝 投稿テスト開始...');
            }, 1000);
        }
        
        function startAutomation() {
            socket.emit('start_automation', {});
            addStatus('🚀 自動化プロセス開始...');
        }
        
        function stopAutomation() {
            socket.emit('stop_automation', {});
            addStatus('⏹️ 自動化プロセス停止');
        }
        
        function captureScreen() {
            socket.emit('capture_screen', {});
            addStatus('📸 画面キャプチャ中...');
        }
    </script>
</body>
</html>
```

## 5. セキュリティ要件

### 5.1 認証情報管理
- パスワードは暗号化して保存
- セッションCookieの安全な管理
- 環境変数での機密情報管理

### 5.2 Bot検出回避
- User-Agentのランダム化
- IPローテーション（プロキシ使用）
- 操作間隔のランダム化
- ブラウザフィンガープリント対策

### 5.3 エラー処理
- 要素が見つからない場合のリトライ
- ネットワークエラーの処理
- セッションタイムアウト対応
- スクリーンショット保存によるデバッグ

## 6. 非機能要件

### 6.1 パフォーマンス
- 1投稿あたり30秒以内で完了
- 同時実行は1セッションのみ（安全性優先）
- メモリ使用量: 2GB以下

### 6.2 可用性
- 自動リトライ機能（最大3回）
- エラー時の自動復旧
- 定期的なヘルスチェック

### 6.3 運用性
- ログファイル出力
- スクリーンショット保存
- 実行履歴のDB記録
- Slack/Email通知

## 7. テストシナリオ

### 7.1 基本テスト
1. **ログインテスト**
   - 正常なログイン
   - 2段階認証
   - ログイン失敗

2. **投稿テスト**
   - テキストのみ投稿
   - 画像付き投稿
   - ハッシュタグ付き投稿

3. **エラーテスト**
   - ネットワーク切断
   - 要素が見つからない
   - タイムアウト

### 7.2 負荷テスト
- 連続10投稿
- 1時間の連続稼働
- メモリリーク確認

## 8. 実装スケジュール

| フェーズ | 内容 | 期間 |
|---------|------|------|
| Phase 1 | 基本的なブラウザ自動化 | 3日 |
| Phase 2 | OCR/画像認識実装 | 2日 |
| Phase 3 | WebSocketサーバー | 2日 |
| Phase 4 | HTMLインターフェース | 1日 |
| Phase 5 | テスト・デバッグ | 2日 |

## 9. リスクと対策

| リスク | 影響度 | 対策 |
|--------|--------|------|
| Threadsの仕様変更 | 高 | セレクタの設定ファイル化 |
| Bot検出される | 高 | 人間的動作の実装 |
| キャプチャ頻発 | 中 | 手動介入フロー |
| セッション切れ | 低 | 自動再ログイン |

## 10. 成功基準

- ✅ 95%以上の投稿成功率
- ✅ Bot検出されない連続稼働24時間
- ✅ 画像認識精度99%以上
- ✅ エラー時の自動復旧率90%以上